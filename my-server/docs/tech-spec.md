# 🎯 PART 2: 비즈니스 로직에 따른 테크 스펙

## 목차

- [개요](#개요)
- [1. 설계 철학 및 핵심](#1-설계-철학-및-핵심)
  - [1.1 Raw vs Override 구조](#11-raw-vs-override-구조)
- [2. ETL 파이프라인과의 경계](#2-etl-파이프라인과의-경계)
- [3. 점유](#3-점유)
- [4. 점유 해제](#4-점유-해제)
  - [4.1 탈퇴](#41-탈퇴)
  - [4.2 180일 자동 만료(INACTIVE 처리)](#42-180일-자동-만료inactive-처리)
- [5. Raw 데이터 변경·삭제에 대한 전략](#5-raw-데이터-변경삭제에-대한-전략)
- [6. 조회 시 덮어쓰기 규칙](#6-조회-시-덮어쓰기-규칙)
- [7. 인증 및 권한 모델](#7-인증-및-권한-모델)
- [8. 오류 처리 정책](#8-오류-처리-정책)
- [9. 대안(Trade-offs)](#9-대안trade-offs)
- [결론](#결론)

## 개요

본 프로젝트는 매월 수집되는 연구자·논문 데이터를 기반으로 사용자가 자신의 연구자 정보를 연결하고, 이후 개인 정보와 논문 정보를 수정·관리할 수 있는 구조를 설계하는 데 목적이 있다. 수집 데이터는 ETL 파이프라인을 통해 매월 주기적으로 최신화되며, 가입 이후의 수정 내용과 충돌하지 않도록 ‘raw 데이터(수집 데이터)’와 ‘override 데이터(가입 이후 수정 내용)’를 분리하는 전략을 사용한다.

또한 ‘연구자 점유’라는 비즈니스 요구사항이 존재하므로, 특정 raw 연구자 엔티티는 하나의 가입한 멤버만 사용할 수 있으며, 탈퇴 또는 자동 만료(연구자 프로필 180일 미수정) 시 점유를 해제해야 한다.

전체 구조는 ‘ETL → raw 저장 → 서비스 레이어: 수정 내용 override → 조회/가입/수정’ 이라는 흐름으로 정리할 수 있다.

## 1. 설계 철학 및 핵심

### 1.1 Raw vs Override 구조

- **raw 데이터(etl_researcher_raw/etl_paper_raw)**
    - 변동 가능
    - read-only
    - 매월 수집/최신화
- **override 데이터(researcher/paper)**
    - 회원이 연결한 후 수정하는 데이터
    - raw 보다 우선 적용
    - 필요한 필드만 저장(null 허용)

이 구조는 요구사항에서 언급된 ‘수집 데이터와 수정 데이터를 모두 유지해야 한다’는 조건을 충족한다.

## 2. ETL 파이프라인과의 경계

ETL을 제외한 모든 서비스 레이어는 ETL 테이블을 직접 수정하지 않는다.

- ETL에서 수집한 데이터는 `etl_researcher_raw`, `etl_paper_raw`
- 가입 후 생성되는 `researcher`, `paper`는 오직 서비스 레이어가 관리하며,  
  raw 데이터 변동 여부에 영향을 받지 않는다.
- 조회 시 덮어쓰기 전략:
  -  raw 데이터의 PK를 기준으로 override 테이블을 LEFT JOIN 한 리스트 가져오기
  -  **researcher 필드를 우선 사용, 없다면 raw 데이터를 fallback으로 사용**  
    (`researcher.data ?? raw.data`)

이 덮어쓰기 규칙으로 인해 raw가 갱신되더라도 사용자가 수정한 값은 유지된다.

## 3. 점유

연구자 점유는 핵심 비즈니스 요구사항이다.
‘한 member는 하나의 연구자 ID만 연결할 수 있다.’

### 구현 방식

- `researcher.etl_researcher_raw_id`에 **UNIQUE** 제약 추가
- 두 사용자가 동일 raw 연구자에 동시에 가입 시도하면 DB에서 충돌 발생
- 서비스 레이어에서는 이 충돌을 감지해
  “이미 다른 사용자가 선택한 연구자입니다.” 형태로 응답

## 4. 점유 해제

### 4.1 탈퇴

회원이 탈퇴하면 다음 처리가 이루어진다.

- `researcher.etl_researcher_raw_id = null`
- `paper.etl_paper_raw_id = null`
- `member.status = DELETED`

점유가 해제되므로 다른 사용자가 동일 raw 연구자를 다시 선택할 수 있게 된다.

### 4.2 180일 자동 만료(INACTIVE 처리)

요구사항에 따라 `researcher.updated_at`을 기준으로 180일 동안 수정이 없으면 자동 만료된다.

- 매일 새벽 실행되는 스케줄러에서 `updated_at` 검증
- 만료 시 `INACTIVE`로 `status` 변경
- raw_id를 모두 null로 세팅하여 점유 해제

만료된 멤버의 `researcher`, `paper` 레코드는 보관되지만 raw_id가 제거되기 때문에, 조회 API에서는 자동으로 raw 데이터가 다시 목록에 등장한다.

## 5. 수집되는 데이터 삭제·형식 변경에 대한 전략

수집되는 외부의 데이터의 형식이 달라지거나 일부 연구자는 제외될 수도 있다. 이를 대응하기 위해 다음 원칙을 따른다.

- raw 데이터는 기록 보존을 위해 데이터베이스에 한번 수집된다면 그대로 유지
  - 연결된 연구자가 존재하는데 base가 되는 raw 데이터를 삭제하는 경우 방지
- 조회 시에는 override 우선이기 때문에 raw의 형식 변경을 커버 가능

## 6. 조회 시 덮어쓰기 규칙

- 필드별 우선순위: override > raw
- `keywords`, `title` 등 배열/문자열 필드와 `updated_at` 은 override 값 존재 시 raw를 완전히 대체
- 논문 목록 또한 override paper 기준의 배열/문자열 필드와 `updated_at` 을 우선
- **프론트엔드는 raw/override의 차이를 고려할 필요가 없으므로 응답에서 보내는 PK 값은 항상 raw 데이터의 PK를 보내는 것으로 통일**

## 7. **인증 및 권한 모델**

api.md에서 Bearer 사용만 간단히 언급했으나, tech-spec에서는 다음 전략을 명시한다.

- JWT 기반 Bearer 토큰 사용
- 토큰에서 `memberId`를 추출하여 모든 서비스 요청의 주체를 결정
- researcher/paper는 항상 `member_id`를 FK로 포함하게 설계함: 권한 검증이 단순해짐
  → 예: paper 수정 요청 시 `paper.member_id === request.member_id` 검사

모든 점유/수정 요청은 강제적인 `member_id` 기반 검증을 거친다.

## 8. 오류 처리 정책

요구사항에 따라 고려할 만한 핵심 오류 정의:

- **이미 점유된 raw 연구자 선택** → 409 CONFLICT
- **존재하지 않는 raw_id** → 404 NOT FOUND
- **본인 소유가 아닌 논문 수정 요청** → 403 FORBIDDEN

## 9. 대안(Trade-offs)

고민 및 검토했던 방안들의 장단점을 정리한다.

### 1) researcher와 paper에 raw 데이터를 전부 복사

- 장점: 조회 계산 단순(조인 없음)
- 단점: 매월 동기화 비용 증가, 저장 공간 낭비

### 2) researcher와 paper 히스토리 남기기

- 장점: 회원 탈퇴 시 override 데이터의 raw_id를 null로 셋팅하기 전 기록을 남겨서 (별도의 테이블 등에),  
탈퇴한 회원이 이전에 어떤 연구자에 대해 점유하고 있었는지 알 수 있는 방법을 제공
- 단점: 요구사항이 아직 없음.
  → **보류**

# **결론**

- 수집 데이터와 수정 데이터를 안전하게 분리하여 운영
- 점유/탈퇴/자동 만료 등 비즈니스 규칙을 DB 제약/스케줄러 기반으로 처리
- 조회 시 raw 위에 override를 자연스럽게 덮어씀 → 프론트에게는 일관된 데이터 제공
